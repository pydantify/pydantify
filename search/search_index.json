{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to pydantify","text":"<p>A prototype CLI tool to transform YANG models into Pydantic datastructures that can be initialized with config values and serialized into RESTCONF payloads.</p>"},{"location":"#usage","title":"Usage","text":"<p>Example:</p> <pre><code>pydantify -i ./models_dir -o ./output_dir -t interfaces/ethernet model.yang\n</code></pre> <p>Transforms the <code>/interfaces/ethernet</code> node and its children (located in <code>model.yang</code>) into a Python script located in <code>./output_dir</code>. Imports of definitions found in <code>./models_dir</code> are included if relevant to the specified model and node.</p> <p>Command syntax:</p> <pre><code>pydantify [-h] [-v] [-V] [-S] [-i INPUT_DIR] [-o OUTPUT_DIR] [-t TRIM_PATH] input_file\n\npositional arguments:\n  input_file            The YANG file containing the entrypoint to the model to evaluate.\n\noptions:\n  -h, --help            show this help message and exit\n  -v, --verbose         Enables debug output\n  -V, --include-verification\n                        Adds validation code, as well as the relevant YANG files, to the output model.\n  -S, --standalone      Generated output model has no dependency on Pydantify.\n                        All required code is copied into the output model.\n  -i INPUT_DIR, --input-dir INPUT_DIR, --path INPUT_DIR\n                        The directory that contains the YANG input model.\n                        Defaults to the input file's folder.\n  -o OUTPUT_DIR, --output-dir OUTPUT_DIR\n                        The directory that should be used to store the output model. Defaults to \"$CWD/out\".\n  -f OUTPUT_FILE, --output-file OUTPUT_FILE\n                        The name of the output file. Defaults to \"out.py\".\n  -t TRIM_PATH, --trim-path TRIM_PATH\n                        Get only the specified branch of the whole tree.\n  -j, --json-schema     Output JSON schema instead of Pydantic models.\n  -d, --data-type {config,state}\n                        Limit output to config or state only. Default is config and state combined.\n\nNOTE: All unknown arguments will be passed to Pyang as-is and without guarantees.\n</code></pre>"},{"location":"architecture/","title":"Architecture","text":"<p>This diagrams created by executing <code>make diagrams</code></p>"},{"location":"architecture/#class-diagram","title":"Class Diagram","text":"<p>Class diagram focusing on <code>models.base</code> and <code>models.models</code>:</p> <pre><code>classDiagram\n  class BaseModel {\n    model_config : ConfigDict\n  }\n  class CaseNode {\n    name() str\n    to_pydantic_model() type[BaseModel]\n  }\n  class ChoiceNode {\n    name() str\n    to_pydantic_model() type[BaseModel]\n  }\n  class ContainerNode {\n    name() str\n  }\n  class GeneratedClass {\n    class_name : str | PydanticUndefinedType\n    cls : Type[BaseModel] | Type[RootModel] | PydanticUndefinedType\n    field_annotation : Type | None\n    field_info : FieldInfo | PydanticUndefinedType\n    assert_is_valid()\n    to_field() Tuple[Type[BaseModel] | Type, FieldInfo]\n  }\n  class LeafListNode {\n    get_base_class() type | Node | Enum\n    name() str\n    to_pydantic_model() type[BaseModel | RootModel]\n  }\n  class LeafNode {\n    get_base_class() type | Node | Enum\n    name() str\n    to_pydantic_model() type[BaseModel | RootModel]\n  }\n  class ListNode {\n    name() str\n    to_pydantic_model() type[BaseModel]\n  }\n  class ModelRoot {\n    root_node : Node | None\n    to_pydantic_model() type[BaseModel] | None\n  }\n  class ModuleNode {\n    name() str\n    to_pydantic_model() type[BaseModel] | type[RootModel]\n  }\n  class Node {\n    alias_mapping : Dict[str, str]\n    arg : str\n    children : List[Node]\n    comments : str | None\n    config : bool\n    default\n    description : str | None\n    keyword : str\n    mandatory : bool\n    raw_statement : Statement\n    substmts : List[Statement]\n    ensure_unique_name(name: str) str\n    extract_statement_list(statement: Statement, attr_name: str) List[Node]\n    get_base_class() type | Node | Enum\n    get_output_class() GeneratedClass\n    get_qualified_name() str\n    make_unique_name(suffix: str)\n    name()* str\n    to_pydantic_model() Type[BaseModel] | Type[RootModel]\n  }\n  class RootModel {\n    model_config : ConfigDict\n  }\n  class TypeDefNode {\n    get_base_class() type | Node | Enum\n    name() str\n    to_pydantic_model() type[RootModel]\n  }\n  CaseNode --|&gt; Node\n  ChoiceNode --|&gt; Node\n  ContainerNode --|&gt; Node\n  LeafListNode --|&gt; Node\n  LeafNode --|&gt; Node\n  ListNode --|&gt; Node\n  ModuleNode --|&gt; Node\n  TypeDefNode --|&gt; Node\n  GeneratedClass --* Node : _output_model\n  GeneratedClass --* CaseNode : _output_model\n  GeneratedClass --* ChoiceNode : _output_model\n  GeneratedClass --* ContainerNode : _output_model\n  GeneratedClass --* LeafListNode : _output_model\n  GeneratedClass --* LeafNode : _output_model\n  GeneratedClass --* ListNode : _output_model\n  GeneratedClass --* ModuleNode : _output_model\n  GeneratedClass --* TypeDefNode : _output_model\n</code></pre>"},{"location":"architecture/#packages-diagram","title":"Packages Diagram","text":"<p>Package overview:</p> <pre><code>classDiagram\n  class pydantify {\n  }\n  class __main__ {\n  }\n  class exceptions {\n  }\n  class main {\n  }\n  class models {\n  }\n  class base {\n  }\n  class models {\n  }\n  class nodefactory {\n  }\n  class typeresolver {\n  }\n  class plugins {\n  }\n  class pydantic_plugin {\n  }\n  class utility {\n  }\n  class function_tools {\n  }\n  class model_generator {\n  }\n  class patterns {\n  }\n  class restconf {\n  }\n  class yang_sources_tracker {\n  }\n  __main__ --&gt; main\n  main --&gt; model_generator\n  models --&gt; base\n  models --&gt; models\n  models --&gt; nodefactory\n  models --&gt; typeresolver\n  base --&gt; nodefactory\n  nodefactory --&gt; exceptions\n  pydantic_plugin --&gt; model_generator\n  utility --&gt; function_tools\n  utility --&gt; restconf\n  utility --&gt; yang_sources_tracker\n</code></pre>"},{"location":"faq/","title":"FAQ","text":""},{"location":"faq/#generated-model-is-empty","title":"Generated model is empty","text":"<p>It looks like Pydantify could not find the entry point. Could it be that your model augments another model? You must use the main model and the path option to select the expected info. You can use <code>pyang</code> to visualize the tree.</p> Example <p>In this example the \"srl nokia ntp\" model augment the \"srl nokia system\" model.</p> <pre><code>$ pyang -f tree -p srlinux-yang-models/ srlinux-yang-models/srlinux-yang-models/srl_nokia/models/system/srl_nokia-ntp.yang\nsrlinux-yang-models/srlinux-yang-models/srl_nokia/models/system/srl_nokia-ntp.yang:18: warning: imported module \"srl_nokia-extensions\" not used\nmodule: srl_nokia-ntp\n\naugment /srl-system:system:\n   +--rw ntp!\n   |  +--rw admin-state?        srl-comm:admin-state\n   |  +--ro oper-state?         srl-comm:oper-state\n   |  +--ro synchronized?       union\n   |  +--rw network-instance    -&gt; /srl_nokia-netinst:network-instance/name\n   |  +--rw source-address?     srl-comm:ip-address\n   |  +--rw server* [address]\n   |     +--rw address            ntp-host\n   |     +--rw iburst?            boolean\n   |     +--rw prefer?            boolean\n   |     +--ro stratum?           uint8\n   |     +--ro jitter?            uint64\n   |     +--ro offset?            uint64\n   |     +--ro root-delay?        uint64\n   |     +--ro root-dispersion?   uint64\n   |     +--ro poll-interval?     uint32\n   +--rw clock\n      +--rw timezone?   srl-tz:tzdata-timezone\n</code></pre> <p>Using the \"srl nokia system\" model, the <code>tree-path</code> option can be used to only see the ntp part.   <pre><code>$ pyang -f tree -p srlinux-yang-models/ srlinux-yang-models/srlinux-yang-models/srl_nokia/models/system/srl_nokia-system.yang srlinux-yang-models/srlinux-yang-models/srl_nokia/models/system/srl_nokia-ntp.yang\n--tree-path=system/ntp\nsrlinux-yang-models/srlinux-yang-models/srl_nokia/models/system/srl_nokia-ntp.yang:18: warning: imported module \"srl_nokia-extensions\" not used\nmodule: srl_nokia-system\n+--rw system\n   +--rw srl_nokia-ntp:ntp!\n      +--rw srl_nokia-ntp:admin-state?        srl-comm:admin-state\n      +--ro srl_nokia-ntp:oper-state?         srl-comm:oper-state\n      +--ro srl_nokia-ntp:synchronized?       union\n      +--rw srl_nokia-ntp:network-instance    -&gt; /srl_nokia-netinst:network-instance/name\n      +--rw srl_nokia-ntp:source-address?     srl-comm:ip-address\n      +--rw srl_nokia-ntp:server* [address]\n         +--rw srl_nokia-ntp:address            ntp-host\n         +--rw srl_nokia-ntp:iburst?            boolean\n         +--rw srl_nokia-ntp:prefer?            boolean\n         +--ro srl_nokia-ntp:stratum?           uint8\n         +--ro srl_nokia-ntp:jitter?            uint64\n         +--ro srl_nokia-ntp:offset?            uint64\n         +--ro srl_nokia-ntp:root-delay?        uint64\n         +--ro srl_nokia-ntp:root-dispersion?   uint64\n         +--ro srl_nokia-ntp:poll-interval?     uint32\n</code></pre></p> <p>Pydantify is a pyang plugin and all options not relevant for pzdantify are passed to pyang.</p> <pre><code>$ pydantify --path=system/ntp srlinux-yang-models/srlinux-yang-models/srl_nokia/models/system/srl_nokia-system.yang srlinux-yang-models/srlinux-yang-models/srl_nokia/models/system/srl_nokia-ntp.yang -p srlinux-yang-models/\n</code></pre>"},{"location":"faq/#pydanticserializationerror-object-has-no-attribute-root","title":"PydanticSerializationError <code>object has no attribute 'root'</code>","text":"<p>This error indicates that an object parameter is being set directly instead of using the <code>RootModel</code> object.</p> Example <p>For this example, let's consider a simplified <code>ServerListEntry</code> object with an address attribute:</p> <pre><code>class ServerListEntry(BaseModel):\n   \"\"\"\n   List of NTP servers to use for system clock synchronization\n   \"\"\"\n\n   model_config = ConfigDict(\n      populate_by_name=True,\n   )\n   address: Annotated[AddressLeaf, Field(None, alias='srl_nokia-ntp:address')]\n</code></pre> <p>The following code snippet is not working as expected because the <code>address</code> type is <code>AddressLeaf</code>, and directly assigning a string breaks the model validation:</p> <pre><code>from out import ServerListEntry\nserver = ServerListEntry()\nserver.address='10.0.0.1'\n</code></pre> <p>To assign a value, an <code>AddressLeaf</code> object is needed:</p> <pre><code>from out import ServerListEntry, AddressLeaf\nserver = ServerListEntry()\nserver.address = AddressLeaf(\"10.0.0.1\")\n</code></pre> <p>When creating an instance of the <code>ServerListEntry</code> object, the string can be passed directly to the constructor because <code>AddressLeaf</code> is a <code>RootModel</code> object:</p> <pre><code>from out import ServerListEntry\nserver = ServerListEntry(address=\"10.0.0.1\")\n</code></pre>"},{"location":"faq/#pydanticserializationerror-nonetype-object-has-no-attribute-root","title":"PydanticSerializationError <code>'NoneType' object has no attribute 'root'</code>","text":"<p>This error occurs when optional RootModel attributes are set to None and need to be excluded when dumping the model.</p> Example <p>When dumping a model, the default values should be excluded using the <code>exclude_defaults=True</code> option:</p> <pre><code>model.model_dump_json(exclude_defaults=True, by_alias=True, indent=2)\n</code></pre> <p>By setting <code>exclude_defaults=True</code>, any attributes with default values of <code>None</code> will be excluded from the dumped model. This helps avoid the <code>'NoneType' object has no attribute 'root'</code> error.</p>"},{"location":"install/","title":"Install","text":"<p>Installation from pypi:</p> <pre><code>pip install pydantify\n</code></pre> <p>pydantify needs Python 3.10 or above. </p>"},{"location":"install/#installing-from-git","title":"Installing from git","text":"<pre><code>pip install git+https://github.com/pydantify/pydantify.git\n</code></pre> <p>pydantify can also be installed in editable mode.</p> <pre><code>git clone https://github.com/pydantify/pydantify.git\npip install -e pydantify\n</code></pre>"},{"location":"install/#create-docker-image","title":"Create docker image","text":"<pre><code>git clone https://github.com/pydantify/pydantify.git\ncd pydantify\ndocker build -t pydantify .\ndocker run --rm -it pydantify\n</code></pre>"},{"location":"examples/hello_world/","title":"Hello World","text":""},{"location":"examples/hello_world/#yang-model","title":"YANG Model","text":"<p>Let's take a simple yang model for a \"Hello World\" example. This model allows specifying a simple endpoint containing an address and port. An optional description can be defined.</p> my-endpoint.yang<pre><code>module my-endpoint {\n  namespace\n  \"http://pydantify.github.io/ns/yang/pydantify-endpoint\";\n\n  prefix \"ep\";\n\n  description 'Example demonstarating leafref nodes';\n\n  typedef port {\n    type uint16 {\n        range \"1 .. 65535\";\n      }\n  }\n\n  container endpoint {\n    description \"Definition of a endpoint\";\n\n    leaf address {\n      type string;\n      description \"Endpoint address. IP or FQDN\";\n      mandatory true;\n    }\n    leaf port {\n      type port;\n      description \"Port number between 1 and 65535\";\n      mandatory true;\n    }\n    leaf description {\n      type string;\n      description \"Endpoint description\";\n    }\n  }\n}\n</code></pre> <p>Using pyang the model can be validated and displayed as a tree.</p> pyang -f tree my-endpoint.yang<pre><code>module: my-endpoint\n  +--rw endpoint\n     +--rw address        string\n     +--rw port           port\n     +--rw description?   string\n</code></pre>"},{"location":"examples/hello_world/#create-pydantic-model","title":"Create pydantic model","text":"<p>Pydantify can now convert the YANG model into a pydantic one.</p> <pre><code>$ pydantify examples/hello_world/my-endpoint.yang\n[INFO] /workspaces/pydantify/pydantify/plugins/pydantic_plugin.py:41 (emit): Output model generated in 0.049s.\n</code></pre> <p>The generated module will be in the file <code>out/out.py</code>. We can move and rename it to <code>endpoint.py</code>.</p> endpoint.py<pre><code>from __future__ import annotations\n\nfrom typing import Optional\n\nfrom pydantic import BaseModel, ConfigDict, Field, RootModel\nfrom typing_extensions import Annotated\n\n\nclass EndpointContainer(BaseModel):\n    \"\"\"\n    Definition of a endpoint\n    \"\"\"\n\n    model_config = ConfigDict(\n        populate_by_name=True,\n        regex_engine=\"python-re\",\n    )\n    address: Annotated[str, Field(alias='my-endpoint:address', title='AddressLeaf')]\n    \"\"\"\n    Endpoint address. IP or FQDN\n    \"\"\"\n    port: Annotated[\n        int, Field(alias='my-endpoint:port', ge=1, le=65535, title='PortLeaf')\n    ]\n    \"\"\"\n    Port number between 1 and 65535\n    \"\"\"\n    description: Annotated[\n        Optional[str], Field(alias='my-endpoint:description', title='DescriptionLeaf')\n    ] = None\n    \"\"\"\n    Endpoint description\n    \"\"\"\n\n\nclass Model(BaseModel):\n    \"\"\"\n    Initialize an instance of this class and serialize it to JSON; this results in a RESTCONF payload.\n\n    ## Tips\n    Initialization:\n    - all values have to be set via keyword arguments\n    - if a class contains only a `root` field, it can be initialized as follows:\n        - `member=MyNode(root=&lt;value&gt;)`\n        - `member=&lt;value&gt;`\n\n    Serialziation:\n    - `exclude_defaults=True` omits fields set to their default value (recommended)\n    - `by_alias=True` ensures qualified names are used (necessary)\n    \"\"\"\n\n    model_config = ConfigDict(\n        populate_by_name=True,\n        regex_engine=\"python-re\",\n    )\n    endpoint: Annotated[\n        Optional[EndpointContainer], Field(alias='my-endpoint:endpoint')\n    ] = None\n\n\nif __name__ == \"__main__\":\n    model = Model(\n        # &lt;Initialize model here&gt;\n    )\n\n    restconf_payload = model.model_dump_json(\n        exclude_defaults=True, by_alias=True, indent=2\n    )\n\n    print(f\"Generated output: {restconf_payload}\")\n\n    # Send config to network device:\n    # from pydantify.utility import restconf_patch_request\n    # restconf_patch_request(url='...', user_pw_auth=('usr', 'pw'), data=restconf_payload)\n</code></pre>"},{"location":"examples/hello_world/#using-the-model","title":"Using the model","text":"<p>The model can now be used as any other pydantic python model, and pydantify is not required if we don't use helper functions from pydantify.</p> <p>The model can be imported, and Python objects can be created. The IDE (like Visual Studio Code) will offer code completion.</p> create_json.py<pre><code>from endpoint import Model, EndpointContainer\n\nport = 8080\nhost = \"localhost\"\n\nendpoint1 = Model(endpoint=EndpointContainer(address=host, port=port))\njson_output = endpoint1.model_dump_json(indent=2, exclude_none=True)\n</code></pre> <p>After creating the objects <code>port</code> and <code>host</code>, the model is instantiated with the passed objects. The pydantic model object can generate JSON directly by calling <code>.json()</code>.</p> <p>By default, the JSON output will include all values. Using the argument <code>exlude_defaults=True</code> will not show these values. In this example, the <code>description</code> leaf is optional and has, therefore, a default value of <code>Null</code>.</p> create_json.py<pre><code>json_output = endpoint1.model_dump_json(exclude_defaults=True, by_alias=True, indent=2)\n</code></pre> <p>With the option <code>by_alias</code> the JSON includes the YANG module name in the keys.</p> endpoint1_json_exclude_default_and_by_alias.json<pre><code>{\n  \"my-endpoint:endpoint\": {\n    \"my-endpoint:address\": \"localhost\",\n    \"my-endpoint:port\": 8080\n  }\n}\n</code></pre> <p>Model objects containing only a <code>root</code> field can be created automatically. So, instead of creating a port object, specify the value in the argument of the <code>EndpointContainer</code> creation. Pydantic creates objects automatically in the background. More information can be found in the pydantic documentation for Custom Root Types</p> create_json.py<pre><code>endpoint2 = Model(\n    endpoint=EndpointContainer(\n        address=\"::1\", port=2222, description=\"Port 2222 on localhost\"\n    )\n)\n</code></pre> endpoint2.json<pre><code>{\n  \"my-endpoint:endpoint\": {\n    \"my-endpoint:address\": \"::1\",\n    \"my-endpoint:port\": 2222,\n    \"my-endpoint:description\": \"Port 2222 on localhost\"\n  }\n}\n</code></pre> <p>A Python dictionary can also be used to create nested model objects:</p> create_json.py<pre><code>endpoint3 = Model(endpoint={\"address\": \"172.0.0.1\", \"port\": 9100})\n</code></pre> endpoint3.json<pre><code>{\n  \"my-endpoint:endpoint\": {\n    \"my-endpoint:address\": \"172.0.0.1\",\n    \"my-endpoint:port\": 9100\n  }\n}\n</code></pre> <p>Using dictionary unpacking, the first level of the dictionary needs to match the field names of the model. Inside the model, also the alias name can be used.</p> create_json.py<pre><code>endpoint4 = Model(\n    **{\"endpoint\": {\"my-endpoint:address\": \"localhost\", \"my-endpoint:port\": 8000}}\n)\n</code></pre> endpoint4.json<pre><code>{\n  \"my-endpoint:endpoint\": {\n    \"my-endpoint:address\": \"localhost\",\n    \"my-endpoint:port\": 8000\n  }\n}\n</code></pre> <p>To be able to use the alias also on the top level, the static class functions <code>parse_obj</code>, <code>parse_file</code>, or <code>parse_raw</code> can be used:</p> create_json.py<pre><code>endpoint5 = Model.model_validate(\n    {\n        \"my-endpoint:endpoint\": {\n            \"my-endpoint:address\": \"remote\",\n            \"my-endpoint:port\": 53,\n        }\n    }\n)\n</code></pre> endpoint5.json<pre><code>{\n  \"my-endpoint:endpoint\": {\n    \"my-endpoint:address\": \"remote\",\n    \"my-endpoint:port\": 53\n  }\n}\n</code></pre>"},{"location":"examples/ietf_interfaces/","title":"IETF Interfaces","text":"<p>Warning</p> <p>Pydantify is still in an alpha state and many parts can hopefully be improved in future versions.</p>"},{"location":"examples/ietf_interfaces/#yang-model","title":"YANG Model","text":"<p>Using pyang the model can be validated and displayed as a tree.</p> pyang -f tree ietf-interfaces.yang<pre><code>module: ietf-interfaces\n  +--rw interfaces\n  |  +--rw interface* [name]\n  |     +--rw name                        string\n  |     +--rw description?                string\n  |     +--rw type                        identityref\n  |     +--rw enabled?                    boolean\n  |     +--rw link-up-down-trap-enable?   enumeration {if-mib}?\n  +--ro interfaces-state\n     +--ro interface* [name]\n        +--ro name               string\n        +--ro type               identityref\n        +--ro admin-status       enumeration {if-mib}?\n        +--ro oper-status        enumeration\n        +--ro last-change?       yang:date-and-time\n        +--ro if-index           int32 {if-mib}?\n        +--ro phys-address?      yang:phys-address\n        +--ro higher-layer-if*   interface-state-ref\n        +--ro lower-layer-if*    interface-state-ref\n        +--ro speed?             yang:gauge64\n        +--ro statistics\n           +--ro discontinuity-time    yang:date-and-time\n           +--ro in-octets?            yang:counter64\n           +--ro in-unicast-pkts?      yang:counter64\n           +--ro in-broadcast-pkts?    yang:counter64\n           +--ro in-multicast-pkts?    yang:counter64\n           +--ro in-discards?          yang:counter32\n           +--ro in-errors?            yang:counter32\n           +--ro in-unknown-protos?    yang:counter32\n           +--ro out-octets?           yang:counter64\n           +--ro out-unicast-pkts?     yang:counter64\n           +--ro out-broadcast-pkts?   yang:counter64\n           +--ro out-multicast-pkts?   yang:counter64\n           +--ro out-discards?         yang:counter32\n           +--ro out-errors?           yang:counter32\n</code></pre> <p>Note</p> <p>Only the model ietf-interfaces is used without any models like ietf-ip, which augment the ietf-interfaces model.</p>"},{"location":"examples/ietf_interfaces/#create-pydantic-model","title":"Create pydantic model","text":"<p>To focus only on the configuration part of the model, the model path can be trimmed to the tree branch <code>ietf-interfaces:interfaces/</code>.</p> <pre><code>$ pydantify -t=ietf-interfaces/interfaces ietf-interfaces.yang\n[INFO] /workspaces/pydantify/pydantify/plugins/pydantic_plugin.py:41 (emit): Output model generated in 0.063s.\n</code></pre> <p>The generated module will be in the file <code>out/out.py</code>. We can move and rename it to <code>ietf_interfaces.py</code>.</p> ietf_interfaces.py ietf_interfaces.py<pre><code>from __future__ import annotations\n\nfrom enum import Enum\nfrom typing import Any, List, Optional\n\nfrom pydantic import BaseModel, ConfigDict, Field, RootModel\nfrom typing_extensions import Annotated\n\n\nclass EnumerationEnum(Enum):\n    enabled = 'enabled'\n    disabled = 'disabled'\n\n\nclass InterfaceListEntry(BaseModel):\n    \"\"\"\n    The list of configured interfaces on the device.\n\n    The operational state of an interface is available in the\n    /interfaces-state/interface list.  If the configuration of a\n    system-controlled interface cannot be used by the system\n    (e.g., the interface hardware present does not match the\n    interface type), then the configuration is not applied to\n    the system-controlled interface shown in the\n    /interfaces-state/interface list.  If the configuration\n    of a user-controlled interface cannot be used by the system,\n    the configured interface is not instantiated in the\n    /interfaces-state/interface list.\n    \"\"\"\n\n    model_config = ConfigDict(\n        populate_by_name=True,\n        regex_engine=\"python-re\",\n    )\n    name: Annotated[\n        Optional[str], Field(alias='ietf-interfaces:name', title='NameLeaf')\n    ] = None\n    \"\"\"\n    The name of the interface.\n\n    A device MAY restrict the allowed values for this leaf,\n    possibly depending on the type of the interface.\n    For system-controlled interfaces, this leaf is the\n    device-specific name of the interface.  The 'config false'\n    list /interfaces-state/interface contains the currently\n    existing interfaces on the device.\n\n    If a client tries to create configuration for a\n    system-controlled interface that is not present in the\n    /interfaces-state/interface list, the server MAY reject\n    the request if the implementation does not support\n    pre-provisioning of interfaces or if the name refers to\n    an interface that can never exist in the system.  A\n    NETCONF server MUST reply with an rpc-error with the\n    error-tag 'invalid-value' in this case.\n\n    If the device supports pre-provisioning of interface\n    configuration, the 'pre-provisioning' feature is\n    advertised.\n\n    If the device allows arbitrarily named user-controlled\n    interfaces, the 'arbitrary-names' feature is advertised.\n\n    When a configured user-controlled interface is created by\n    the system, it is instantiated with the same name in the\n    /interface-state/interface list.\n    \"\"\"\n    description: Annotated[\n        Optional[str],\n        Field(alias='ietf-interfaces:description', title='DescriptionLeaf'),\n    ] = None\n    \"\"\"\n    A textual description of the interface.\n\n    A server implementation MAY map this leaf to the ifAlias\n    MIB object.  Such an implementation needs to use some\n    mechanism to handle the differences in size and characters\n    allowed between this leaf and ifAlias.  The definition of\n    such a mechanism is outside the scope of this document.\n\n    Since ifAlias is defined to be stored in non-volatile\n    storage, the MIB implementation MUST map ifAlias to the\n    value of 'description' in the persistently stored\n    datastore.\n\n    Specifically, if the device supports ':startup', when\n    ifAlias is read the device MUST return the value of\n    'description' in the 'startup' datastore, and when it is\n    written, it MUST be written to the 'running' and 'startup'\n    datastores.  Note that it is up to the implementation to\n\n    decide whether to modify this single leaf in 'startup' or\n    perform an implicit copy-config from 'running' to\n    'startup'.\n\n    If the device does not support ':startup', ifAlias MUST\n    be mapped to the 'description' leaf in the 'running'\n    datastore.\n    \"\"\"\n    type: Annotated[Any, Field(alias='ietf-interfaces:type', title='TypeLeaf')]\n    \"\"\"\n    The type of the interface.\n\n    When an interface entry is created, a server MAY\n    initialize the type leaf with a valid value, e.g., if it\n    is possible to derive the type from the name of the\n    interface.\n\n    If a client tries to set the type of an interface to a\n    value that can never be used by the system, e.g., if the\n    type is not supported or if the type does not match the\n    name of the interface, the server MUST reject the request.\n    A NETCONF server MUST reply with an rpc-error with the\n    error-tag 'invalid-value' in this case.\n    \"\"\"\n    enabled: Annotated[\n        Optional[bool], Field(alias='ietf-interfaces:enabled', title='EnabledLeaf')\n    ] = True\n    \"\"\"\n    This leaf contains the configured, desired state of the\n    interface.\n\n    Systems that implement the IF-MIB use the value of this\n    leaf in the 'running' datastore to set\n    IF-MIB.ifAdminStatus to 'up' or 'down' after an ifEntry\n    has been initialized, as described in RFC 2863.\n\n\n\n    Changes in this leaf in the 'running' datastore are\n    reflected in ifAdminStatus, but if ifAdminStatus is\n    changed over SNMP, this leaf is not affected.\n    \"\"\"\n    link_up_down_trap_enable: Annotated[\n        Optional[EnumerationEnum],\n        Field(\n            alias='ietf-interfaces:link-up-down-trap-enable',\n            title='Link-up-down-trap-enableLeaf',\n        ),\n    ] = None\n    \"\"\"\n    Controls whether linkUp/linkDown SNMP notifications\n    should be generated for this interface.\n\n    If this node is not configured, the value 'enabled' is\n    operationally used by the server for interfaces that do\n    not operate on top of any other interface (i.e., there are\n    no 'lower-layer-if' entries), and 'disabled' otherwise.\n    \"\"\"\n\n\nclass InterfacesContainer(BaseModel):\n    \"\"\"\n    Interface configuration parameters.\n    \"\"\"\n\n    model_config = ConfigDict(\n        populate_by_name=True,\n        regex_engine=\"python-re\",\n    )\n    interface: Annotated[\n        Optional[List[InterfaceListEntry]], Field(alias='ietf-interfaces:interface')\n    ] = None\n\n\nclass Model(BaseModel):\n    \"\"\"\n    Initialize an instance of this class and serialize it to JSON; this results in a RESTCONF payload.\n\n    ## Tips\n    Initialization:\n    - all values have to be set via keyword arguments\n    - if a class contains only a `root` field, it can be initialized as follows:\n        - `member=MyNode(root=&lt;value&gt;)`\n        - `member=&lt;value&gt;`\n\n    Serialziation:\n    - `exclude_defaults=True` omits fields set to their default value (recommended)\n    - `by_alias=True` ensures qualified names are used (necessary)\n    \"\"\"\n\n    model_config = ConfigDict(\n        populate_by_name=True,\n        regex_engine=\"python-re\",\n    )\n    interfaces: Annotated[\n        Optional[InterfacesContainer], Field(alias='ietf-interfaces:interfaces')\n    ] = None\n\n\nif __name__ == \"__main__\":\n    model = Model(\n        # &lt;Initialize model here&gt;\n    )\n\n    restconf_payload = model.model_dump_json(\n        exclude_defaults=True, by_alias=True, indent=2\n    )\n\n    print(f\"Generated output: {restconf_payload}\")\n\n    # Send config to network device:\n    # from pydantify.utility import restconf_patch_request\n    # restconf_patch_request(url='...', user_pw_auth=('usr', 'pw'), data=restconf_payload)\n</code></pre>"},{"location":"examples/ietf_interfaces/#parse-json-data-into-the-model","title":"Parse JSON data into the model","text":"<p>Using requests, or any other HTTP library, the data can be retrieved in JSON format.</p> restconf.py<pre><code>response = session.get(f\"https://{host}/restconf/data/ietf-interfaces:interfaces\")\nresponse.raise_for_status()\n</code></pre> <p>The output depends on the network device. This example uses a Cisco CSR1k with three interfaces.</p> restconf data<pre><code>{\n  \"ietf-interfaces:interfaces\": {\n    \"interface\": [\n      {\n        \"name\": \"GigabitEthernet1\",\n        \"description\": \"MANAGEMENT INTERFACE - DON'T TOUCH ME\",\n        \"type\": \"iana-if-type:ethernetCsmacd\",\n        \"enabled\": true,\n        \"ietf-ip:ipv4\": {\n          \"address\": [\n            {\n              \"ip\": \"10.10.20.48\",\n              \"netmask\": \"255.255.255.0\"\n            }\n          ]\n        },\n        \"ietf-ip:ipv6\": {}\n      },\n      {\n        \"name\": \"GigabitEthernet2\",\n        \"description\": \"https://pydantify.github.io/pydantify/\",\n        \"type\": \"iana-if-type:ethernetCsmacd\",\n        \"enabled\": true,\n        \"ietf-ip:ipv4\": {},\n        \"ietf-ip:ipv6\": {}\n      },\n      {\n        \"name\": \"GigabitEthernet3\",\n        \"description\": \"Configured and Merged by Ansible Network\",\n        \"type\": \"iana-if-type:ethernetCsmacd\",\n        \"enabled\": false,\n        \"ietf-ip:ipv4\": {},\n        \"ietf-ip:ipv6\": {}\n      }\n    ]\n  }\n}\n</code></pre> <p>The received response from the device includes data from the ietf-ip model, which augment the ietf-interfaces model. Because the build model does not have these fields, the model configuration must be set to ignore extra fields (default). Pydantic Configuration extra</p> restconf.py<pre><code>from ietf_interfaces import Model\n\nmodel = Model.model_validate(response.json())\n\nprint(model.model_dump_json(exclude_defaults=True, by_alias=True, indent=2))\n</code></pre> <p>Now the model is filled with the received data. By using the option <code>by_alias=True</code>, all keys contain the model prefix in the output.</p> model output<pre><code>{\n  \"ietf-interfaces:interfaces\": {\n    \"ietf-interfaces:interface\": [\n      {\n        \"ietf-interfaces:name\": \"GigabitEthernet1\",\n        \"ietf-interfaces:description\": \"MANAGEMENT INTERFACE - DON'T TOUCH ME\",\n        \"ietf-interfaces:type\": \"iana-if-type:ethernetCsmacd\",\n        \"ietf-interfaces:enabled\": true\n      },\n      {\n        \"ietf-interfaces:name\": \"GigabitEthernet2\",\n        \"ietf-interfaces:description\": \"Configured and Merged by Ansible Network\",\n        \"ietf-interfaces:type\": \"iana-if-type:ethernetCsmacd\",\n        \"ietf-interfaces:enabled\": false\n      },\n      {\n        \"ietf-interfaces:name\": \"GigabitEthernet3\",\n        \"ietf-interfaces:description\": \"Configured and Merged by Ansible Network\",\n        \"ietf-interfaces:type\": \"iana-if-type:ethernetCsmacd\",\n        \"ietf-interfaces:enabled\": false\n      }\n    ]\n  }\n}\n</code></pre> <p>As with all Python objects, you can access them and make evaluations.</p> restconf.py<pre><code>for interface in model.interfaces.interface:\n    print(\n        \"Interface {name} is {status}\".format(\n            name=interface.name,\n            status=\"enabled\" if interface.enabled else \"disabled\",\n        )\n    )\n</code></pre> <p>The first interface is the management interface and is enabled; the other two are disabled.</p> Interface status<pre><code>Interface GigabitEthernet1 is enabled\nInterface GigabitEthernet2 is disabled\nInterface GigabitEthernet3 is disabled\n</code></pre>"},{"location":"examples/ietf_interfaces/#updatechange-model","title":"Update/change model","text":"<p>This example takes the second interface, changes the interface to enable, and updates the description.</p> restconf.py<pre><code>from ietf_interfaces import DescriptionLeaf, EnabledLeaf, InterfacesContainer\n\ninterface = model.interfaces.interface[1]\ninterface.enabled = True\ninterface.description = \"https://pydantify.github.io/pydantify/\"\n</code></pre> <p>Taking a look at only this level of the tree, the generated output contains the changes.</p> updated interface<pre><code>{\n  \"ietf-interfaces:name\": \"GigabitEthernet2\",\n  \"ietf-interfaces:description\": \"https://pydantify.github.io/pydantify/\",\n  \"ietf-interfaces:type\": \"iana-if-type:ethernetCsmacd\",\n  \"ietf-interfaces:enabled\": true\n}\n</code></pre> <p>For an easy configuration update, a new model can be created only containing the changed interface.</p> restconf.py<pre><code>new_model = Model(interfaces=InterfacesContainer(interface=[interface]))\n</code></pre> <p>Now the output contains all layers of the YANG tree starting at the root interfaces field.</p> new model output<pre><code>{\n  \"ietf-interfaces:interfaces\": {\n    \"ietf-interfaces:interface\": [\n      {\n        \"ietf-interfaces:name\": \"GigabitEthernet2\",\n        \"ietf-interfaces:description\": \"https://pydantify.github.io/pydantify/\",\n        \"ietf-interfaces:type\": \"iana-if-type:ethernetCsmacd\",\n        \"ietf-interfaces:enabled\": true\n      }\n    ]\n  }\n}\n</code></pre>"},{"location":"examples/ietf_interfaces/#update-device-configuration","title":"Update device configuration","text":"<p>Using the newly created model from the top, a PATCH request can be sent to the device using the root URL of the model (same URL was used to get the data).</p> exclude_defaults=True <p>It is recommended to use the option <code>exlude_defaults=True</code> not to send unnecessary data.</p> restconf.py<pre><code>response = session.patch(\n    f\"https://{host}/restconf/data/ietf-interfaces:interfaces/\",\n    data=new_model.model_dump_json(exclude_defaults=True, by_alias=True),\n)\n</code></pre> <p>To address the interface directly using the URL, to not only update but also be able to replace the configuration, the data structure needs not a map containing a list of interfaces but a map containing a map looking like this:</p> JSON paylod to address interface direclty<pre><code>{\n  \"ietf-interfaces:interface\": {\n    \"ietf-interfaces:name\": \"GigabitEthernet2\",\n    \"ietf-interfaces:description\": \"https://pydantify.github.io/pydantify/\",\n    \"ietf-interfaces:type\": \"iana-if-type:ethernetCsmacd\",\n    \"ietf-interfaces:enabled\": true,\n  }\n}\n</code></pre> <p>Now the URL must include the interface like <code>ietf-interfaces:interfaces/interface=GigabitEthernet2</code>.</p> restconf.py<pre><code>response = session.patch(\n    f\"https://{host}/restconf/data/ietf-interfaces:interfaces/interface=GigabitEthernet2\",\n    json={\n        \"ietf-interfaces:interface\": interface.model_dump(\n            exclude_defaults=True, by_alias=True\n        )\n    },\n)\n</code></pre>"},{"location":"technologies/dmcg/","title":"datamodel-code-generator","text":"<p>Note</p> <p>This text has been gratefully copied from the Term project documentation by D. Jovicic and D. Walther.</p> <p>Datamodel-code-generator (or DMCG for short) is a project which aims to translate data models written in either the ApenAPI 3 or JSONSchema format into Python class structures based on pydantic. While it is primarily designed as a CLI tool, it can easily be used as a library and integrated into other projects (though the lack of documentation surrounding this use-case requires some reverse-engineering).</p> <p>Some notable features include:</p> <ul> <li>automatic generation of import statements based on the types and methods present in the schema being translated</li> <li>support for annotating classes via Python docstrings for ease of use within IDEs</li> <li>ability to re-use and reference other classes within the schema (meaning two classes containing a field of the same type do not lead to said type appearing twice in the output model)</li> <li>ability to rename classes and fields in order to not cause syntax errors, while still allowing initialization by the original name through pydantic's <code>alias</code> attribute</li> </ul>"},{"location":"technologies/pyang/","title":"pyang","text":"<p>Note</p> <p>This text has been gratefully copied from the Term project documentation by D. Jovicic and D. Walther.</p> <p>Pyang describes itself as \"a YANG validator, transformator and code generator, written in Python\". It is capable of translating YANG modules between various formats including YANG, YIN, DSDL, jsTree, among others. The library is extensible through plugins, most notably PyangBind and pyang-pydantic.</p> <p>Being widely used in the industry while having released version 1.0 over 12 years ago should indicate that it is a fairly reliable tool. However, being that old comes at a cost: it maintains backwards compatibility all the way to Python 2.7. It does so by using only the subset of Python instructions valid in both Python 2.7 and 3.6, occasionally using branching code paths where necessary. It therefore comes with no type hints, f-strings, list comprehensions, match-case statements or any number of other features that have improved the legibility of Python code since the Python 2.7 release.</p>"},{"location":"technologies/pyang/#usage","title":"Usage","text":"<p>Pyang is primarily designed to be used as a CLI tool, but it does offer a few additional options:</p> <p>There are other options however:</p> <ul> <li>Using Pyang as an intermediate translation step<ul> <li>pro: this would expand our tool options. For example YIN (which is effectively XML) can be interpreted by off-the-shelve Python libraries, making it easier for us to parse.</li> <li>pro: we would not need to concern ourselves with any of the Pyang internals.</li> <li>con: on its own, this would require any YANG to pydantic conversion to be done in multiple steps (Eg. translating YANG to YIN using Pyang, then generating a pydantic model from said YIN output).</li> </ul> </li> <li>Using Pyang as a library<ul> <li>pro: models could be used directly upon loading, without translating them to another format first. This could eliminate the need for an additional dependency in the chain.</li> <li>con: as this is not the primary intended use-case, there is no intended interface for us to use, leading to increased coupling as we would need to access the library's internals directly.</li> </ul> </li> <li>Extending Pyang with a plugin of our own<ul> <li>pro: it's the intended interface by which to add functionality to pyang, giving us greater guarantees that the components we would rely on will stay the same.</li> <li>con: implemented this way, our project would effectively be a pure translator, running only when the user requires a model to be converted from one format to another. This would limit our ability to add functionality designed to aid the user after the initial conversion. For example, if the user intends to modify the pydantic schema we would likely not be able to offer any editing tools (Eg. pruning a branch of the model-tree would have to be done manually by the user). Any mistakes by the user would only be noticeable when attempting to convert the pydantic model back to a YANG module, requiring a trial-and-error approach.</li> <li>additional complication: neither of us has prior experience writing extensions for third-party software, leading to more uncertainty in our estimates for potential risks and challenges.</li> </ul> </li> </ul>"},{"location":"technologies/pyang/#pyang-in-depth","title":"Pyang In-Depth","text":"<p>In this chapter, we will cover the pyang project in more detail, specifically the parts relevant to our project. It is by no means a comprehensive review, but it should serve as a crash-course for anyone improving upon or maintaining our project.</p>"},{"location":"technologies/pyang/#the-plugin-system","title":"The plugin system","text":"<p>Pyang can be extended at runtime through a fairly typical plugin interface. The <code>pyang</code> console-command supports a <code>--plugindir=\"&lt;path&gt;\"</code> flag that, if present, prompts Pyang to look for additional plugins situated at the given path and import them through the importlib library.</p> <p>For Pyang to recognise a Python script as a valid plugin, it needs to contain a <code>pyang_plugin_init()</code> function. This function will be called by Pyang once it is ready to initialize plugins and must in turn call <code>register_plugin()</code> with an instance of a class which inherits from <code>PyangPlugin</code> as its argument. Said class must:</p> <ul> <li>Call the super-class' constructor with its own name as the argument.</li> <li>Implement <code>add_output_format(self, fmts)</code> to associate the plugin with a given output file format.</li> <li>Implement <code>emit(self, ctx, modules, fd)</code>, which gets called after Pyang has parsed a YANG model if the user requests the output to be in the associated format.</li> </ul> <p>This shows a Pyang plugin with no additional functionality:</p> Barebones Pyang plugin<pre><code>from pyang.plugin import PyangPlugin, register_plugin\nfrom pyang.statements import ModSubmodStatement\nfrom pyang.context import Context\nfrom typing import List, Dict\n\n\ndef pyang_plugin_init():\n  register_plugin(MyPlugin())\n\n\nclass MyPlugin(PyangPlugin):\n  def __init__(self):\n    # Pass on the name of the plugin\n    super().__init__(name=\"my-plugin-name\")\n\n  def add_output_format(self, fmts: Dict[str, PyangPlugin]):\n    # Register self as the plugin in charge of \"my-format\" inputs\n    fmts[\"my-format\"] = self\n\n  def emit(self, ctx: Context, modules: List[ModSubmodStatement], fd):\n    # Main functionality goes here.\n    # Once converted, write the output to the \"fd\" file-descriptor.\n    pass\n</code></pre> <p>This approach works quite well, but it does come with a slight disadvantage, namely that the plugins folder can not contain any non-plugin files in order to avoid Pyang logging it as an error. This has slight implications on the project's structure, as it requires a separate folder just for the plugin's entry-point.</p>"},{"location":"technologies/pyang/#pyang-classes","title":"Pyang classes","text":""},{"location":"technologies/pyang/#statements","title":"Statements","text":"<p>Statements represent most of the common YANG keywords such as <code>module</code>, <code>list</code>, <code>leaf</code>, <code>container</code>, <code>type</code>, etc. These are effectively the nodes in the YANG tree structure and are all derived from a common <code>Statement</code> class, often with very few additions.</p> <p><code>Statement</code> instances make heavy use of Python <code>__slots__</code>, which is effectively a whitelist of field names that are allowed within the instance. This means that, unlike conventional classes, arbitrary fields cannot be added to an instance at runtime. Additionally, the way these <code>__slots__</code> are used in Pyang leads to many of the fields being declared but not initialized, causing exceptions to be raised when accessed, even by an IDE. This, combined with YANG's heavy use of optional substatements can lead to situations in which the majority of a <code>Statement</code>'s fields are undefined. Direct access to fields therefore needs careful consideration.</p> <p>The <code>Statement</code> class also offers most of the functionality required for tree traversal, including <code>search()</code> and <code>search_one()</code> to locate the statement's children and substatements by either their <code>keyword</code> or <code>arg</code> values along with <code>main_module()</code>, used to find the root module of the tree. To simplify navigation even further, each <code>Statement</code> contains a reference to its <code>parent</code>. For debugging and logging purposes, each <code>Statement</code> also contains a <code>pos</code> field, referencing the file and line number from which it was parsed - a welcome addition when working on cross-referential models split up across several files.</p>"},{"location":"technologies/pyang/#typespecs","title":"TypeSpecs","text":"<p><code>TypeSpec</code> and its derived classes hold information about the underlying type of a node. They contain the base type (for example an integer, float or string) and the restrictions the value must adhere to to be considered valid. These restrictions typically consist of value ranges, length restrictions, regular expressions (called \"patterns\") or pre-defined values (called \"enums\").</p> <p>These classes also contain a <code>validate()</code> function which, as the name implies, validates whether a given value matches the restrictions imposed on the type. Unfortunately for pydantify, these functions are tightly coupled to the Pyang project and cannot be easily repurposed for input validation in the output model.</p>"},{"location":"technologies/pydantic/","title":"pydantic","text":"<p>Note</p> <p>This text has been gratefully copied from the Term project documentation by D. Jovicic and D. Walther.</p> <p>Pydantic is a data validation library for Python with some very appealing features:</p> <ul> <li>It can do runtime type-checking of arguments when instantiating classes or assigning to one of its member fields</li> <li>It allows even complex class structures with inheritance and compositions to be instantiated with a JSON-like dictionary</li> <li>It can serialize the content of a class to JSON, provided it consists only of python-native types or if custom serialization functions are provided for non-native types</li> <li>It can serialize and de-serialize a class structure, allowing it to be stored or sent as JSON</li> <li>It can do automatic type-casting and conversion between native types, allowing it to inter-operate with applications written in untyped languages, such as JavaScript</li> <li>Despite relying heavily on generic and dynamically generated classes, it provides a lot of type-hinting information to the IDE, making it easy to work with</li> </ul> <p>These features are provided through a series of classes any developer should be familiar with when using pydantic for their project. The rest of this subsection aims to provide an overview of said classes and their purpose.</p>"},{"location":"technologies/pydantic/#basemodel","title":"BaseModel","text":"<p>The <code>BaseModel</code> class lies at the heart of every pydantic project. It is the base class each class needs to inherit from, if it wants to make use of the aforementioned pydantic features and become a Pydantic Model.</p> <p>When a class inherits from <code>BaseModel</code>, it fundamentally changes how the class works. For instance, member fields are no longer declared in the <code>__init__()</code> method, instead needing to be declared directly in the class body like conventional static members. Type annotation also plays a crucial role, as pydantic tries to convert any input given during construction to the annotated type - if no type is provided or the provided type is unknown to pydantic (meaning it does not inherit from <code>BaseModel</code>, nor provide its own validator), an exception is raised by default. Additionally, such a class can automatically be instantiated from a dictionary of its fields, even without declaring an <code>__init__()</code> method explicitly.</p> <p>The integration with Python's dictionary type does not end there however. Any class inheriting from <code>BaseModel</code> can be serialized to a schema-dictionary via the <code>.schema()</code> method. Any properties pertaining to the data of the class are preserved in said schema, such as field types, names, defaults and value constraints in a way that is compatible with JSON Schema Core and OpenAPI. Other class attributes such as methods, however, are not included, which is relevant when used in combination with the Datamodel Code Generator (DMCG).</p>"},{"location":"technologies/pydantic/#config","title":"Config","text":"<p>Defining a <code>Config</code> class within a model adds the option of modifying model-wide settings. Some of the most widely used settings include ((pydantic docs)[https://docs.pydantic.dev/usage/model_config/#options]):</p> <ul> <li><code>allow_mutation</code>: whether <code>__setattr__()</code> is allowed</li> <li><code>arbitrary_types_allowed</code>: whether to allow arbitrary user types for fields (validation simply consists of checking if the type matches when enabled)</li> <li><code>extra</code>: whether to ignore, allow, or forbid extra attributes during initialization</li> <li><code>underscore_attrs_are_private</code>: whether to treat any underscore fields as private, or leave them as is</li> <li><code>validate_assignment</code>: whether to perform validation on assignment to attributes</li> </ul>"},{"location":"technologies/pydantic/#type-annotation-and-validation","title":"Type Annotation and Validation","text":"<p>Input validation in pydantic is primarily declared via type-annotation. Pydantic's validation supports numerous types and therefore will be summarized aggressively here. (A complete list of supported types can be found at https://pydantic-docs.helpmanual.io/usage/types/)</p> <ul> <li>Most native Python types are supported, including but not limited to: <code>bool</code>, <code>int</code>, <code>str</code>, <code>bytes</code>, <code>list</code>, <code>dict</code> and <code>tuple</code>.</li> <li>Various types of <code>enum</code> are supported.</li> <li>Various types found in the ipaddress library are supported for IP validation.</li> <li>Most types provided by the typing library are supported, including <code>Optional</code>, <code>Union</code>, <code>Sequence</code>, <code>Type</code>, <code>Callable</code>, <code>Pattern</code> and <code>Annotated</code>.</li> <li>Pydantic offers several additional constrained types, such as <code>stricturl</code>, <code>PositiveFloat</code>, <code>conint</code> and <code>constr</code>. Most of these are built upon other types, with additional customizable restrictions.</li> <li>If the supported types are not sufficient, custom ones can be added by creating classes that provide their own validators via a <code>__get_validators__()</code> method, even if they do not inherit from <code>BaseModel</code>.</li> </ul>"},{"location":"technologies/yang/","title":"YANG","text":"<p>Note</p> <p>This text has been gratefully copied from the Term project documentation by D. Jovicic and D. Walther.</p> <p>YANG (short for \"Yet Another Next Generation\") is a data modeling language that was designed to improve upon the limitations of SNMP (Simple Network Management Protocol) in configuration management. While SNMP is commonly used as a network management system to detect errors on network devices, its disadvantages sparked a need for the creation of a better protocol. In 2006, the IETF published NETCONF, a standardized protocol for automating network configurations. NETCONF allows for the retrieval, upload, manipulation, and deletion of configuration data. However, NETCONF only defines the process of transmitting and modifying data, not the structure of the data itself. This lead to the to the development of YANG. YANG makes it easier to understand data models and is widely used in the networking industry.</p> <p>YANG is hierarchical, provides high extensibility and can distinguish between configurations and status. In other words, YANG complements NETCONF so that it is possible to define configuration and state data, notifications and Remote Procedure Calls using NETCONF-based operations.</p> <p>A YANG module defines a single data model, however, it can reference definitions from other modules by using the <code>import</code> and <code>include</code> statements. YANG, as defined in RFC6020, has four primary node types, as shown in the table below.</p> Type Description Comparable to <code>leaf</code> represents a single value a variable <code>leaf-list</code> contains a sequence of leaf nodes an array <code>container</code> contains a group of related nodes a class <code>list</code> contains a sequence of nodes, each uniquely identified by one or more key attributes a database table YANG Model Interface Common Example<pre><code>grouping passive-interface-grouping {\n  container passive-interface {\n    description\n      \"Suppress routing updates on an interface\";\n    choice passive-interface-choice {\n      leaf default {\n        description\n          \"Suppress routing updates on all interfaces\";\n        type empty;\n      }\n      leaf-list interface {\n        type string;\n      }\n    }\n  }\n  container disable {\n    when '../passive-interface/default';\n    list passive-interface {\n      key \"interface\";\n      leaf interface {\n        type string;\n      }\n    }\n  }\n}\n</code></pre>"},{"location":"technologies/yang/#typedef","title":"typedef","text":"<p>By using the <code>typedef</code> statement, one can define types derived from a base type. This base type can either be a built-in type, such as <code>string</code> or <code>uint8</code>, or an already derived type. This allows for a basic form of inheritance between types, where the root type is always a built-in type.</p> <p>For example, a type called <code>percent</code> can be defined, which is derived from the base type <code>uint8</code> and has its value restricted to between 0 and 100.</p> typedef percent<pre><code>typedef percent {\n    type uint8 {\n        range \"0 .. 100\";\n    }\n}\n</code></pre> <p>Such a type can then be referenced by other statements, such as <code>leaf</code>. The <code>completion</code> leaf can be thought of as a variable of type <code>percent</code>.</p> typedef percent usage example<pre><code>leaf completion {\n    type percent;\n}\n</code></pre>"},{"location":"technologies/yang/#leafref","title":"leafref","text":"<p>The <code>leafref</code> type is a little bit more complicated to understand than the other types.</p> <p>The <code>leafref</code> type is used to reference other <code>leaf</code> instances in the tree via its \"path\" sub-statement. The \"path\" statement takes a string as an argument and must refer to an existing leaf or a <code>leaf-list</code> node, dangling references are not allowed.</p> Simple leafref yang example<pre><code>list interface {\n  key \"name\";\n  leaf name {\n    type string;\n  }\n  leaf admin-status {\n    type admin-status;\n  }\n  list address {\n    key \"ip\";\n    leaf ip {\n      type yang:ip-address;\n    }\n  }\n}\n\nleaf mgmt-interface {\n  type leafref {\n    path \"../interface/name\";\n  }\n}\n</code></pre> <p>We can see that the <code>leafref</code> refers to the path <code>\"../interface/name\"</code>, meaning that the leaf it is referring to can be found by leaving the scope of the current node, navigating into the \"interface\" list and finally locating the node called \"name\". A corresponding XML is shown below.</p> Simple leafref XML example<pre><code>&lt;interface&gt;\n    &lt;name&gt;eth0&lt;/name&gt;\n&lt;/interface&gt;\n&lt;interface&gt;\n    &lt;name&gt;lo&lt;/name&gt;\n&lt;/interface&gt;\n\n&lt;mgmt-interface&gt;eth0&lt;/mgmt-interface&gt;\n</code></pre>"},{"location":"technologies/yang/#restconf","title":"RESTCONF","text":"<p>We took a short excursion into the history of the creation of NETCONF and YANG, but there is one more component to it - the RESTCONF protocol. RESTCONF is a protocol based on HTTP that provides an interface to access data defined in YANG, while using the data store concepts of NETCONF.</p> <p>The goal of both YANG, NETCONF and RESTCONF is to facilitate the automation of network configurations. While NETCONF is based on RPC (Remote Procedure Call), something many companies would need to re-train their IT-Engineers for in order to use, RESTCONF uses HTTP-based RESTful APIs, which are much more ubiquitous in the industry.</p> <p>RESTCONF tends to be easier to work with for simple CRUD operations when compared to NETCONF, and its ability to work with both XML and JSON data makes it a bit more flexible to integrate with other software, such as in our case.</p> <p>All in all, RESTCONF is an easy way for applications to access configuration and state data, data-model-specific RPC operations, and event notifications.</p> <p>The operations provided by RESTCONF are defined in RFC8040 and can be summarized thusly:</p> <ul> <li>OPTIONS<ul> <li>Is sent to discover which methods (options) are supported by the opposing side for a specified resource</li> </ul> </li> <li>GET<ul> <li>Is sent to retrieve data and metadata of a specified resource</li> </ul> </li> <li>HEAD<ul> <li>Is sent to retrieve just the header fields from a specified resource</li> </ul> </li> <li>POST<ul> <li>Is sent by the client to create a data resource or invoke a Remote Procedure Call</li> </ul> </li> <li>PUT<ul> <li>Is sent to create or replace the data of a specified resource</li> </ul> </li> <li>PATCH<ul> <li>Is used to provide an extensible framework for resource patching mechanisms and can be used to create or modify a child resource within the specified resource</li> </ul> </li> <li>DELETE<ul> <li>Is used to delete the specified resource</li> </ul> </li> </ul>"},{"location":"technologies/yang/#xpath","title":"XPath","text":"<p>XML Path Language, or XPath for short, was designed to support the query of XML structures. The simplest form an XPath statement can take would be a complete and internal path, such as <code>interfaces/ip</code>, which selects a child node called <code>ip</code> located in a node called <code>interfaces</code>. There are many, much more complex queries that can be performed through XPath, an introduction to which can be found on the W3Schools website.</p> <p>In YANG, XPath is used in for referencing other nodes or to specify restrictions on them. Here are a few examples of where XPath finds application in YANG:</p> <p>Must Statements are used to constraint nodes; in the example below, we want to make sure that the value of <code>count</code> is exactly 10.</p> XPath must statement<pre><code>container interface {\n    must \"count = 10\";\n    leaf count {\n        type uint8\n    }\n}\n</code></pre> <p>If/When Statements are used to make instances of YANG conditional. The <code>when</code> statements can change at run-time, whereas <code>if</code> statements are set on boot-time. The YANG example describes a <code>leaf</code> called \"name\", which is only present in the data if the value of <code>percent</code> is below 50.</p> XPath when statement<pre><code>container test {\n    leaf percent {\n        type uint8\n    }\n    leaf name {\n        when \"../percent &lt; 50\";\n        type string\n    }\n}\n</code></pre> <p>Path Statements, as described in the section leafref, are the most common application of XPath within YANG. They are essential for the functioning of leafrefs as they specify which YANG node is being referenced. They can also be used to add additional restrictions on the properties the node to be referenced must have, allowing them to be used as a form of foreign key constraint.</p>"},{"location":"technologies/yang/#xpath-in-pydantify","title":"XPath in Pydantify","text":"<p>All in all, XPath is a powerful feature, but making use of it is not a trivial affair. For instance the <code>path</code> statements can only be checked as the model is being instantiated with data, meaning that the validity of the input can only be tested after Pydantify has already completed its task of generating a pydantic output model.</p> <p>In addition, queries like <code>if</code> and <code>when</code> can alter which components are included in the model dynamically based on input values. To fully reproduce this behaviour in the output model would require the output model to be self-modifying, adding a layer of meta-programming which would easily exceed the scope of our project.</p> <p>It would however be possible to validate the input after the instantiation of the output model by having pyang check the generated RESTCONF payload against the YANG model. This would allows the the configuration data to be validated fully, without having to implement the validation ourselves. The only downside being that the YANG files have to be preserved alongside the output model in order to provide this functionality.</p>"}]}